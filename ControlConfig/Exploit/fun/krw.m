//
//  krw.c
//  kfd
//
//  Created by Seo Hyun-gyu on 2023/07/29.
//

#include "krw.h"
#include "helpers.h"
#include "libkfd.h"

uint64_t _kfd = 0;

uint64_t do_kopen(uint64_t puaf_pages, uint64_t puaf_method,
                  uint64_t kread_method, uint64_t kwrite_method) {
  //    size_t size = 0;
  //    sysctlbyname("kern.version", NULL, &size, NULL, 0);
  //    char *current_kern_version = malloc(size);
  //    if (current_kern_version == NULL) {
  //        fprintf(stderr, "Error: failed to allocate memory for kernel version
  //        string\n"); exit(1);
  //    }
  //    if (sysctlbyname("kern.version", current_kern_version, &size, NULL, 0)
  //    != 0) {
  //        fprintf(stderr, "Error: failed to retrieve kernel version
  //        string\n"); free(current_kern_version); exit(1);
  //    }
  //    t1sz_boot = strstr(current_kern_version, "T8120") != NULL ? 17ull :
  //    25ull; free(current_kern_version);
  //
  //    printf("t1sz_boot = %lld\n", t1sz_boot);

  _kfd = kopen(puaf_pages, puaf_method, kread_method, kwrite_method);
  return _kfd;
}

uint64_t try_existing_kfd_kopen(uint64_t kfd_addr) {
  printf("[-] trying existing kopen at address %llu", kfd_addr);
  if (kfd_addr == 0) {
    printf("[-] existing kopen at address %llu is invalid", kfd_addr);
    return 0;
  }
  struct kfd *kfd = (struct kfd *)(uintptr_t)(kfd_addr);
  if (kfd != NULL && kfd->info.kaddr.kernel_proc != 0) {
    printf("[-] using existing kopen at address %llu", kfd_addr);
    _kfd = (u64)kfd;
    return _kfd;
  } else {
    printf("[-] existing kopen at address %llu is invalid", kfd_addr);
    return 0;
  }
}

void do_kclose(void) { kclose((struct kfd *)(_kfd)); }

void do_kread(u64 kaddr, void *uaddr, u64 size) {
  kread(_kfd, kaddr, uaddr, size);
}

void do_kwrite(void *uaddr, u64 kaddr, u64 size) {
  kwrite(_kfd, uaddr, kaddr, size);
}

uint64_t get_kslide(void) { return ((struct kfd *)_kfd)->perf.kernel_slide; }

uint64_t get_kernproc(void) {
  return ((struct kfd *)_kfd)->info.kaddr.kernel_proc;
}

uint8_t kread8(uint64_t where) {
  uint8_t out;
  kread(_kfd, where, &out, sizeof(uint8_t));
  return out;
}
uint32_t kread16(uint64_t where) {
  uint16_t out;
  kread(_kfd, where, &out, sizeof(uint16_t));
  return out;
}
uint32_t kread32(uint64_t where) {
  uint32_t out;
  kread(_kfd, where, &out, sizeof(uint32_t));
  return out;
}
uint64_t kread64(uint64_t where) {
  uint64_t out;
  kread(_kfd, where, &out, sizeof(uint64_t));
  return out;
}

// Thanks @jmpews
uint64_t kread64_smr(uint64_t where) {
  uint64_t value = kread64(where) | 0xffffff8000000000;
  if ((value & 0x400000000000) != 0)
    value &= 0xFFFFFFFFFFFFFFE0;
  return value;
}

void kwrite8(uint64_t where, uint8_t what) {
  uint8_t _buf[8] = {};
  _buf[0] = what;
  _buf[1] = kread8(where + 1);
  _buf[2] = kread8(where + 2);
  _buf[3] = kread8(where + 3);
  _buf[4] = kread8(where + 4);
  _buf[5] = kread8(where + 5);
  _buf[6] = kread8(where + 6);
  _buf[7] = kread8(where + 7);
  kwrite((u64)(_kfd), &_buf, where, sizeof(u64));
}

void kwrite16(uint64_t where, uint16_t what) {
  u16 _buf[4] = {};
  _buf[0] = what;
  _buf[1] = kread16(where + 2);
  _buf[2] = kread16(where + 4);
  _buf[3] = kread16(where + 6);
  kwrite((u64)(_kfd), &_buf, where, sizeof(u64));
}

void kwrite32(uint64_t where, uint32_t what) {
  u32 _buf[2] = {};
  _buf[0] = what;
  _buf[1] = kread32(where + 4);
  kwrite((u64)(_kfd), &_buf, where, sizeof(u64));
}
void kwrite64(uint64_t where, uint64_t what) {
  u64 _buf[1] = {};
  _buf[0] = what;
  kwrite((u64)(_kfd), &_buf, where, sizeof(u64));
}
